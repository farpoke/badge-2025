# This CMake file is a mix of the autogenerated one from the RPi Pico VS Code extension,
# the micropython/ports/rp2/CMakeLists.txt file, and custom additions/modifications.
#
# The micropython commands in particular appear to be quite fragile; handle with care.

cmake_minimum_required(VERSION 3.31)

set(CMAKE_C_STANDARD 11)
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

find_package(Python3 REQUIRED)

# Initialise pico_sdk from installed location
# (note this can come from environment, CMake cache etc)

# == DO NOT EDIT THE FOLLOWING LINES for the Raspberry Pi Pico VS Code Extension to work ==
if(WIN32)
    set(USERHOME $ENV{USERPROFILE})
else()
    set(USERHOME $ENV{HOME})
endif()
set(sdkVersion 2.1.1)
set(toolchainVersion 14_2_Rel1)
set(picotoolVersion 2.1.1)
set(picoVscode ${USERHOME}/.pico-sdk/cmake/pico-vscode.cmake)
if (EXISTS ${picoVscode})
    include(${picoVscode})
endif()
# ====================================================================================

# Look for the pico board headers in the badge directory, specifically our `badge-2025.h` header.
set(PICO_BOARD_HEADER_DIRS ${CMAKE_SOURCE_DIR}/badge)
set(PICO_BOARD badge-2025 CACHE STRING "Board type")

# Our final PCB has a whole 16 MiB of FLASH.
set(PICO_FLASH_SIZE_BYTES "16 * 1024 * 1024")

# Name of our project and target.
set(TARGET badge-2025)

# Pull in the pico SDK (must be before project).
include(pico_sdk_import.cmake)

# Define CMake project.
project(${TARGET} C CXX ASM)

# Initialise the Raspberry Pi Pico SDK.
pico_sdk_init()

# Create target executable with our minimum sources.
add_executable(${TARGET}
        main.cpp
        badge/buttons.cpp
        badge/drawing.cpp
        badge/irq.cpp
        badge/lcd.cpp
        badge/storage.cpp
        fs/msc.cpp
        ui/state.cpp
        ui/ui.cpp
        usb/stdio_driver.cpp
        usb/usb-descriptors.cpp
        usb/usb.cpp
        utils/crc.cpp
)
target_include_directories(${TARGET} PRIVATE
        ${CMAKE_CURRENT_LIST_DIR}
        ${CMAKE_CURRENT_LIST_DIR}/usb
)

# Add the option of producing a smaller "factory test" version.
set(FACTORY_TEST OFF CACHE BOOL "Build factory test firmware")

if(FACTORY_TEST)

    # Add the factory test source file and set the macro to one.
    target_sources(${TARGET} PRIVATE badge/factory_test.cpp)
    target_compile_definitions(${TARGET} PRIVATE FACTORY_TEST=1)

else()

    # Set the factory test macro to zero.
    target_compile_definitions(${TARGET} PRIVATE FACTORY_TEST=0)

    # Add our non-required sources.
    target_sources(${TARGET} PRIVATE
            main.cpp
            badge/animation.cpp
            badge/flags.cpp
            badge/font.cpp
            fs/fs.cpp
            games/blocks.cpp
            games/flappy.cpp
            games/othello.cpp
            games/snek.cpp
            ui/animations.cpp
            ui/code_entry.cpp
            ui/flag_view.cpp
            ui/menu.cpp
            ui/qr_code.cpp
            ui/readme.cpp
            ui/splash.cpp
    )

    # Include our assets and add them to our target.
    add_subdirectory(assets)
    target_link_libraries(${TARGET} assets)

endif()

target_compile_definitions(${TARGET} PUBLIC
        # Use all 8 KiB of "scratch" memory for the core0 stack.
        # We will allocate some memory for the core1 stack elsewhere.
        PICO_STACK_SIZE=0x2000
        PICO_CORE1_STACK_SIZE=0
        # Enable/disable debug print in malloc.
        PICO_DEBUG_MALLOC=0
)

target_compile_options(${TARGET} PRIVATE
        # Ask the compiler to check and warn us about stack usage.
        -fstack-usage
        -Wstack-usage=5120
        # Ask the compiler to be very strict.
        -Wall
        -Werror
        # Ask the compiler to always include debug information.
        -g
)

# core1 has a much smaller stack, so warn about much smaller stack usage for that code unit.
set_source_files_properties(core/core1.cpp PROPERTIES COMPILE_OPTIONS "-Wstack-usage=1024")

# Ask the compiler to always optimize some more critical pieces of code.
set_source_files_properties(
        badge/drawing.cpp
        badge/font.cpp
        badge/lcd.cpp
        PROPERTIES COMPILE_OPTIONS "-O2"
)

# Set the target program name and version for the Pico SDK.
pico_set_program_name(${TARGET} "badge-2025")
pico_set_program_version(${TARGET} "0.1")

# Configure pico SDK stdio.
pico_enable_stdio_uart(${TARGET} 1) # Enable stdio over UART (with the pins we define in our board header).
pico_enable_stdio_usb(${TARGET} 0)  # No stdio over USB; we set up our own CDC and MSC interfaces.

# Add pico SDK libraries to our target.
target_link_libraries(${TARGET}
        hardware_base
        hardware_clocks
        hardware_dma
        hardware_flash
        hardware_gpio
        hardware_interp
        hardware_irq
        hardware_pwm
        hardware_regs
        hardware_resets
        hardware_rtc
        hardware_spi
        hardware_structs
        hardware_timer
        hardware_uart
        pico_aon_timer
        pico_base_headers
        pico_bootsel_via_double_reset
        pico_flash
        pico_platform
        pico_platform_compiler
        pico_platform_panic
        pico_platform_sections
        pico_rand
        pico_stdio
        pico_stdlib
        pico_time
        pico_util
        tinyusb_device
)

# Add in our DOOM port.
# add_subdirectory(doom)
# target_link_libraries(${TARGET} doom)

# Ask the pico SDK to generate extra outputs for our target.
pico_add_extra_outputs(${TARGET})

# Ask the toolchain to give us a disassembled output file.
pico_get_runtime_output_directory(${TARGET} output_path)
add_custom_command(
        TARGET
            ${TARGET}
        POST_BUILD
        COMMAND
            ${CMAKE_OBJDUMP}
        ARGS
            -xSC
            $<TARGET_FILE:${TARGET}>
            > ${output_path}$<IF:$<BOOL:$<TARGET_PROPERTY:${TARGET},OUTPUT_NAME>>,$<TARGET_PROPERTY:${TARGET},OUTPUT_NAME>,$<TARGET_PROPERTY:${TARGET},NAME>>.txt
        VERBATIM
)

# Add post-build command to run the analyze-map script.
add_custom_target(analyze-map
        COMMAND
            ${CMAKE_COMMAND} -E env PYTHONIOENCODING=utf8
            -- ${Python3_EXECUTABLE} ${CMAKE_CURRENT_LIST_DIR}/tools/analyze-map.py $<TARGET_FILE:${TARGET}>.map
        DEPENDS ${TARGET}
        VERBATIM
        COMMENT "Run analyze-map script..."
)
